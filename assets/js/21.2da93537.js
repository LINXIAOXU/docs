(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{320:function(v,_,t){"use strict";t.r(_);var a=t(6),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"测试的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试的分类"}},[v._v("#")]),v._v(" 测试的分类")]),v._v(" "),t("h2",{attrs:{id:"一-按项目流程阶段划分（测试阶段）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-按项目流程阶段划分（测试阶段）"}},[v._v("#")]),v._v(" 一. 按项目流程阶段划分（测试阶段）")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("单元测试")]),v._v("：单元测试是对软件中的基本组成单位进行的测试。目的是检验软件基本组成单位的正确性。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("集成测试")]),v._v("：集成测试是在软件系统集成过程中所进行的测试。目的是检查软件单位之间的接口是否正确。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("系统测试")]),v._v("：系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("验收测试")]),v._v("：验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买都展示该软件系统满足其用户的需求。")])])]),v._v(" "),t("h3",{attrs:{id:"单元测试阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单元测试阶段"}},[v._v("#")]),v._v(" 单元测试阶段")]),v._v(" "),t("p",[v._v("单元测试是对软件组成单元进行测试。其目的是检验软件基本组成单位的正确性。测试的对象是软件设计的最小单位：模块。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("测试阶段：编码后")])]),v._v(" "),t("li",[t("p",[v._v("测试对象：最小模块")])]),v._v(" "),t("li",[t("p",[v._v("测试人员：白盒测试工程师或开发工程师")])]),v._v(" "),t("li",[t("p",[v._v("测试依据：代码和注释+详细设计文档")])]),v._v(" "),t("li",[t("p",[v._v("测试方法：白盒测试")])]),v._v(" "),t("li",[t("p",[v._v("测试内容：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试")])])]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("模块接口测试")])]),v._v(" "),t("p",[v._v("通过所测模块的数据流进行测试。调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("局部数据结构测试")])]),v._v(" "),t("p",[v._v("局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整、正确、模块的局部数据结构往往是错误的根源。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("路径测试")])]),v._v(" "),t("p",[v._v("对模块中重要的执行路径进行测试。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("错误处理测试")])]),v._v(" "),t("p",[v._v("比较完善的模块设计要求能遇见出错的条件，并设置适当的出错处理，以便在一旦程序出错时，能对出错程序重做安排，保证其逻辑上的正确性。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("边界条件测试")])]),v._v(" "),t("p",[v._v("软件经常在边界上失效，边界条件测试是一项基础测试，也是后面系统测试中的功能测试的重点。")])])]),v._v(" "),t("h3",{attrs:{id:"集成测试阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集成测试阶段"}},[v._v("#")]),v._v(" 集成测试阶段")]),v._v(" "),t("p",[v._v("集成测试也称联合测试、组装测试，将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("测试阶段：一般单元测试之后进行")])]),v._v(" "),t("li",[t("p",[v._v("测试对象：模块间的接口")])]),v._v(" "),t("li",[t("p",[v._v("测试人员：白盒测试工程师或开发工程师")])]),v._v(" "),t("li",[t("p",[v._v("测试依据：单元测试的模块+概要设计文档")])]),v._v(" "),t("li",[t("p",[v._v("测试方法：黑盒测试与白盒测试相结合")])]),v._v(" "),t("li",[t("p",[v._v("测试内容：模块之间数据传输、模块之间功能冲突、模块组装功能正确性、全局数据结构、单模块缺陷对系统的影响")])])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("把各个模块连接起来时，穿越模块接口的数据据是否会丢失。")])]),v._v(" "),t("li",[t("p",[v._v("各个了模块组合起来，能否达到预期要求的功能。")])]),v._v(" "),t("li",[t("p",[v._v("一个模块的功能是否会对另一个模块的功能产生不利影响。")])]),v._v(" "),t("li",[t("p",[v._v("全局数据据结构是否有问题。")])]),v._v(" "),t("li",[t("p",[v._v("单个模块的误差积累起来是否会被放大，从而达到不可接受的程序。")])])]),v._v(" "),t("h3",{attrs:{id:"系统测试阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统测试阶段"}},[v._v("#")]),v._v(" 系统测试阶段")]),v._v(" "),t("p",[v._v("将软件系统看成是一个系统的测试。包括对功能、性能以及软件所运行的软硬件环境进行测试。一般系统的主要测试工作都集中系统测试阶段。根据不同的系统，所进行的测试种类也很多。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("测试阶段：集成测试通过之后")])]),v._v(" "),t("li",[t("p",[v._v("测试对象：整个系统（软、硬件）")])]),v._v(" "),t("li",[t("p",[v._v("测试人员：黑盒测试工程师")])]),v._v(" "),t("li",[t("p",[v._v("测试依据：需求规格说明文档")])]),v._v(" "),t("li",[t("p",[v._v("测试方法：黑盒测试")])]),v._v(" "),t("li",[t("p",[v._v("测试内容：功能、界面、可靠性、易用性、性能、兼容性、安全性等")])])]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("功能测试")])]),v._v(" "),t("p",[v._v("功能测试是对产品的各功能进行验证，以检查是否满足需求的要求。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("性能测试")])]),v._v(" "),t("p",[v._v("性能测试是通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("安全测试")])]),v._v(" "),t("p",[v._v("安全测试检查系统对非法入侵的防范能力。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("兼容测试")])]),v._v(" "),t("p",[v._v("兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行。")])])]),v._v(" "),t("h3",{attrs:{id:"验收测试阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验收测试阶段"}},[v._v("#")]),v._v(" 验收测试阶段")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("功能确认测试")])]),v._v(" "),t("li",[t("p",[v._v("安全可靠性测试")])]),v._v(" "),t("li",[t("p",[v._v("易用性测试")])]),v._v(" "),t("li",[t("p",[v._v("可扩充性测试")])]),v._v(" "),t("li",[t("p",[v._v("兼容性测试")])]),v._v(" "),t("li",[t("p",[v._v("资源占用率测试")])]),v._v(" "),t("li",[t("p",[v._v("用户文档资料验收")])])]),v._v(" "),t("h2",{attrs:{id:"二-按是否查看代码划分（测试方法）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-按是否查看代码划分（测试方法）"}},[v._v("#")]),v._v(" 二. 按是否查看代码划分（测试方法）")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("黑盒测试")]),v._v("：黑盒测试也称功能测试，测试中把被测的软件当成一个黑盒子，不关心盒子的内部结构是什么，只关心软件的输入数据与输出数据。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("功能测试：界面测试、冒烟测试、回归测试、业务逻辑测试、兼容性测试、易用性测试")])]),v._v(" "),t("li",[t("p",[v._v("性能测试：性能测试、负载测试、压力测试、容量测试、并发测试、配置测试、可靠性测试")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("白盒测试")]),v._v("：白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒指的打开盒子，去研究里面的源代码和程序结果。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("灰盒测试")]),v._v("：灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。")])])]),v._v(" "),t("h2",{attrs:{id:"三-按是否执行程序划分（测试方式）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-按是否执行程序划分（测试方式）"}},[v._v("#")]),v._v(" 三. 按是否执行程序划分（测试方式）")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("静态测试")]),v._v("：静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("检查项：代码风格和规则审核；程序设计和结构的审核；业务逻辑的审核；走查、审查与技术复审手册。")])]),v._v(" "),t("li",[t("p",[v._v("静态质量：度量所依据的标准是ISO9126。在该标准中，软件的质量用以下几个方面来衡量，即功能性(Functionality)、可靠性(Reliability)、可用性(Usability)、有效性(Efficiency)、可维护性（Maintainability）、可移植性(Portability)。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("动态测试")]),v._v("：动态测试方法是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等性能。这种方法由三部分组成：构造测试用例、执行程序、分析程序的输出结果。")])])]),v._v(" "),t("h2",{attrs:{id:"四-按是否查看代码划分（测试自动化程度）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-按是否查看代码划分（测试自动化程度）"}},[v._v("#")]),v._v(" 四. 按是否查看代码划分（测试自动化程度）")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("手工测试")]),v._v("：手工测试就是由人去一个一个的输入用例，然后观察结果，和机器测试相对应，属于比较原始但是必须的一个步骤。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("优点：自动化无法替代探索性测试、发散思维类无既定结果的测试。")])]),v._v(" "),t("li",[t("p",[v._v("缺点：执行效率慢，量大易错。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("自动化测试")]),v._v("：就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。简单说自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。")])])]),v._v(" "),t("p",[v._v("自动化测试比如功能测试自动化、性能测试自动化、安全测试自动化。")]),v._v(" "),t("p",[v._v("通常所说的自动化是指功能测试自动化。")]),v._v(" "),t("h2",{attrs:{id:"五-其他汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-其他汇总"}},[v._v("#")]),v._v(" 五. 其他汇总")]),v._v(" "),t("h3",{attrs:{id:"冒烟测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒烟测试"}},[v._v("#")]),v._v(" 冒烟测试")]),v._v(" "),t("p",[v._v("在《微软项目求生法则》一书第14章“构建过程”关于冒烟测试，就是开发人员在个人版本的软件上执行目前的冒烟测试项目，确定新的程序代码不出故障。")]),v._v(" "),t("p",[v._v("冒烟测试目的是确认软件基本功能正常，冒烟测试的执行者是版本编译人员。")]),v._v(" "),t("p",[v._v("现基本执行对象为测试人员，在正规测试一个新版本之前，投入较少的人力和时间验证基本功能，通过则测试准入。")]),v._v(" "),t("h3",{attrs:{id:"随机测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#随机测试"}},[v._v("#")]),v._v(" 随机测试")]),v._v(" "),t("p",[v._v("随机测试主要是根据测试者的经验对软件进行功能和性能抽查。")]),v._v(" "),t("p",[v._v("根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。")]),v._v(" "),t("p",[v._v("随机测试主要是对被测软件的一些重要功能进行复测，也包括测试那些当前的测试用例(TestCase)没有覆盖到的部分。")]),v._v(" "),t("h3",{attrs:{id:"安全测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全测试"}},[v._v("#")]),v._v(" 安全测试")]),v._v(" "),t("p",[v._v("安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程 。")]),v._v(" "),t("h3",{attrs:{id:"探索性测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#探索性测试"}},[v._v("#")]),v._v(" 探索性测试")]),v._v(" "),t("p",[v._v("探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。")]),v._v(" "),t("p",[v._v("探索性测试自动化暂时无法代替")]),v._v(" "),t("h3",{attrs:{id:"回归测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回归测试"}},[v._v("#")]),v._v(" 回归测试")]),v._v(" "),t("p",[v._v("回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。")]),v._v(" "),t("p",[v._v("在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。通过选择正确的回归测试策略来改进回归测试的效率和有效性是很有意义的。")]),v._v(" "),t("h3",{attrs:{id:"α测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#α测试"}},[v._v("#")]),v._v(" α测试")]),v._v(" "),t("p",[v._v("α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。α测试的目的是评价软件产品的FLURPS(即功能、局域化、可使用性、可靠性、性能和支持)。")]),v._v(" "),t("p",[v._v("大型通用软件，在正式发布前，通常需要执行Alpha和Beta测试。α测试不能由程序员或测试员完成。")]),v._v(" "),t("h3",{attrs:{id:"β测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#β测试"}},[v._v("#")]),v._v(" β测试")]),v._v(" "),t("p",[v._v("Beta测试是一种验收测试。Beta测试由软件的最终用户们在一个或多个客房场所进行。")]),v._v(" "),t("p",[t("strong",[v._v("α测试与Beta测试的区别")]),v._v("：")]),v._v(" "),t("p",[v._v("测试的场所不同：Alpha测试是指把用户请到开发方的场所来测试,beta测试是指在一个或多个用户的场所进行的测试。")]),v._v(" "),t("p",[v._v("Alpha测试的环境是受开发方控制的,用户的数量相对比较少,时间比较集中。beta测试的环境是不受开发方控制的,用户数量相对比较多,时间不集中。")]),v._v(" "),t("p",[v._v("alpha测试先于beta测试执行。通用的软件产品需要较大规模的beta测试,测试周期比较长。")])])}),[],!1,null,null,null);_.default=s.exports}}]);